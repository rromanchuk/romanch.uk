import{Loader as e,LoaderUtils as t,FileLoader as s,Color as n,LinearSRGBColorSpace as o,SpotLight as r,PointLight as i,DirectionalLight as a,MeshBasicMaterial as c,SRGBColorSpace as l,MeshPhysicalMaterial as u,Vector2 as h,Matrix4 as d,Vector3 as m,Quaternion as p,InstancedMesh as f,InstancedBufferAttribute as T,Object3D as A,Interpolant as g,NearestFilter as x,LinearFilter as E,NearestMipmapNearestFilter as R,LinearMipmapNearestFilter as _,NearestMipmapLinearFilter as L,LinearMipmapLinearFilter as v,ClampToEdgeWrapping as w,MirroredRepeatWrapping as M,RepeatWrapping as S,InterpolateLinear as y,InterpolateDiscrete as I,MeshStandardMaterial as b,FrontSide as N,TextureLoader as C,ImageBitmapLoader as F,BufferAttribute as O,InterleavedBuffer as P,InterleavedBufferAttribute as G,Texture as H,PointsMaterial as U,Material as D,LineBasicMaterial as k,DoubleSide as B,PropertyBinding as K,BufferGeometry as j,SkinnedMesh as V,Mesh as X,TriangleStripDrawMode as z,TriangleFanDrawMode as q,LineSegments as Q,Line as W,LineLoop as Y,Points as Z,Group as J,PerspectiveCamera as $,MathUtils as ee,OrthographicCamera as te,Skeleton as se,AnimationClip as ne,Bone as oe,VectorKeyframeTrack as re,NumberKeyframeTrack as ie,QuaternionKeyframeTrack as ae,Box3 as ce,Sphere as le,ColorManagement as ue}from"three";import{t as he}from"../../../_/CZA97F6h.js";class GLTFLoader extends e{constructor(e){super(e);this.dracoLoader=null;this.ktx2Loader=null;this.meshoptDecoder=null;this.pluginCallbacks=[];this.register((function(e){return new GLTFMaterialsClearcoatExtension(e)}));this.register((function(e){return new GLTFMaterialsDispersionExtension(e)}));this.register((function(e){return new GLTFTextureBasisUExtension(e)}));this.register((function(e){return new GLTFTextureWebPExtension(e)}));this.register((function(e){return new GLTFTextureAVIFExtension(e)}));this.register((function(e){return new GLTFMaterialsSheenExtension(e)}));this.register((function(e){return new GLTFMaterialsTransmissionExtension(e)}));this.register((function(e){return new GLTFMaterialsVolumeExtension(e)}));this.register((function(e){return new GLTFMaterialsIorExtension(e)}));this.register((function(e){return new GLTFMaterialsEmissiveStrengthExtension(e)}));this.register((function(e){return new GLTFMaterialsSpecularExtension(e)}));this.register((function(e){return new GLTFMaterialsIridescenceExtension(e)}));this.register((function(e){return new GLTFMaterialsAnisotropyExtension(e)}));this.register((function(e){return new GLTFMaterialsBumpExtension(e)}));this.register((function(e){return new GLTFLightsExtension(e)}));this.register((function(e){return new GLTFMeshoptCompression(e)}));this.register((function(e){return new GLTFMeshGpuInstancing(e)}))}load(e,n,o,r){const i=this;let a;if(this.resourcePath!=="")a=this.resourcePath;else if(this.path!==""){const s=t.extractUrlBase(e);a=t.resolveURL(s,this.path)}else a=t.extractUrlBase(e);this.manager.itemStart(e);const _onError=function(t){r?r(t):console.error(t);i.manager.itemError(e);i.manager.itemEnd(e)};const c=new s(this.manager);c.setPath(this.path);c.setResponseType("arraybuffer");c.setRequestHeader(this.requestHeader);c.setWithCredentials(this.withCredentials);c.load(e,(function(t){try{i.parse(t,a,(function(t){n(t);i.manager.itemEnd(e)}),_onError)}catch(e){_onError(e)}}),o,_onError)}setDRACOLoader(e){this.dracoLoader=e;return this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(e){this.ktx2Loader=e;return this}setMeshoptDecoder(e){this.meshoptDecoder=e;return this}register(e){this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e);return this}unregister(e){this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1);return this}parse(e,t,s,n){let o;const r={};const i={};const a=new TextDecoder;if(typeof e==="string")o=JSON.parse(e);else if(e instanceof ArrayBuffer){const t=a.decode(new Uint8Array(e,0,4));if(t===me){try{r[de.KHR_BINARY_GLTF]=new GLTFBinaryExtension(e)}catch(e){n&&n(e);return}o=JSON.parse(r[de.KHR_BINARY_GLTF].content)}else o=JSON.parse(a.decode(e))}else o=e;if(o.asset===void 0||o.asset.version[0]<2){n&&n(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const c=new GLTFParser(o,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});c.fileLoader.setRequestHeader(this.requestHeader);for(let e=0;e<this.pluginCallbacks.length;e++){const t=this.pluginCallbacks[e](c);t.name||console.error("THREE.GLTFLoader: Invalid plugin found: missing name");i[t.name]=t;r[t.name]=true}if(o.extensionsUsed)for(let e=0;e<o.extensionsUsed.length;++e){const t=o.extensionsUsed[e];const s=o.extensionsRequired||[];switch(t){case de.KHR_MATERIALS_UNLIT:r[t]=new GLTFMaterialsUnlitExtension;break;case de.KHR_DRACO_MESH_COMPRESSION:r[t]=new GLTFDracoMeshCompressionExtension(o,this.dracoLoader);break;case de.KHR_TEXTURE_TRANSFORM:r[t]=new GLTFTextureTransformExtension;break;case de.KHR_MESH_QUANTIZATION:r[t]=new GLTFMeshQuantizationExtension;break;default:s.indexOf(t)>=0&&i[t]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+t+'".')}}c.setExtensions(r);c.setPlugins(i);c.parse(s,n)}parseAsync(e,t){const s=this;return new Promise((function(n,o){s.parse(e,t,n,o)}))}}function GLTFRegistry(){let e={};return{get:function(t){return e[t]},add:function(t,s){e[t]=s},remove:function(t){delete e[t]},removeAll:function(){e={}}}}const de={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_DISPERSION:"KHR_materials_dispersion",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_MATERIALS_BUMP:"EXT_materials_bump",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class GLTFLightsExtension{constructor(e){this.parser=e;this.name=de.KHR_LIGHTS_PUNCTUAL;this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser;const t=this.parser.json.nodes||[];for(let s=0,n=t.length;s<n;s++){const n=t[s];n.extensions&&n.extensions[this.name]&&n.extensions[this.name].light!==void 0&&e._addNodeRef(this.cache,n.extensions[this.name].light)}}_loadLight(e){const t=this.parser;const s="light:"+e;let c=t.cache.get(s);if(c)return c;const l=t.json;const u=l.extensions&&l.extensions[this.name]||{};const h=u.lights||[];const d=h[e];let m;const p=new n(16777215);d.color!==void 0&&p.setRGB(d.color[0],d.color[1],d.color[2],o);const f=d.range!==void 0?d.range:0;switch(d.type){case"directional":m=new a(p);m.target.position.set(0,0,-1);m.add(m.target);break;case"point":m=new i(p);m.distance=f;break;case"spot":m=new r(p);m.distance=f;d.spot=d.spot||{};d.spot.innerConeAngle=d.spot.innerConeAngle!==void 0?d.spot.innerConeAngle:0;d.spot.outerConeAngle=d.spot.outerConeAngle!==void 0?d.spot.outerConeAngle:Math.PI/4;m.angle=d.spot.outerConeAngle;m.penumbra=1-d.spot.innerConeAngle/d.spot.outerConeAngle;m.target.position.set(0,0,-1);m.add(m.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+d.type)}m.position.set(0,0,0);m.decay=2;assignExtrasToUserData(m,d);d.intensity!==void 0&&(m.intensity=d.intensity);m.name=t.createUniqueName(d.name||"light_"+e);c=Promise.resolve(m);t.cache.add(s,c);return c}getDependency(e,t){if(e==="light")return this._loadLight(t)}createNodeAttachment(e){const t=this;const s=this.parser;const n=s.json;const o=n.nodes[e];const r=o.extensions&&o.extensions[this.name]||{};const i=r.light;return i===void 0?null:this._loadLight(i).then((function(e){return s._getNodeRef(t.cache,i,e)}))}}class GLTFMaterialsUnlitExtension{constructor(){this.name=de.KHR_MATERIALS_UNLIT}getMaterialType(){return c}extendParams(e,t,s){const r=[];e.color=new n(1,1,1);e.opacity=1;const i=t.pbrMetallicRoughness;if(i){if(Array.isArray(i.baseColorFactor)){const t=i.baseColorFactor;e.color.setRGB(t[0],t[1],t[2],o);e.opacity=t[3]}i.baseColorTexture!==void 0&&r.push(s.assignTexture(e,"map",i.baseColorTexture,l))}return Promise.all(r)}}class GLTFMaterialsEmissiveStrengthExtension{constructor(e){this.parser=e;this.name=de.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,t){const s=this.parser;const n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const o=n.extensions[this.name].emissiveStrength;o!==void 0&&(t.emissiveIntensity=o);return Promise.resolve()}}class GLTFMaterialsClearcoatExtension{constructor(e){this.parser=e;this.name=de.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const t=this.parser;const s=t.json.materials[e];return s.extensions&&s.extensions[this.name]?u:null}extendMaterialParams(e,t){const s=this.parser;const n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const o=[];const r=n.extensions[this.name];r.clearcoatFactor!==void 0&&(t.clearcoat=r.clearcoatFactor);r.clearcoatTexture!==void 0&&o.push(s.assignTexture(t,"clearcoatMap",r.clearcoatTexture));r.clearcoatRoughnessFactor!==void 0&&(t.clearcoatRoughness=r.clearcoatRoughnessFactor);r.clearcoatRoughnessTexture!==void 0&&o.push(s.assignTexture(t,"clearcoatRoughnessMap",r.clearcoatRoughnessTexture));if(r.clearcoatNormalTexture!==void 0){o.push(s.assignTexture(t,"clearcoatNormalMap",r.clearcoatNormalTexture));if(r.clearcoatNormalTexture.scale!==void 0){const e=r.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new h(e,e)}}return Promise.all(o)}}class GLTFMaterialsDispersionExtension{constructor(e){this.parser=e;this.name=de.KHR_MATERIALS_DISPERSION}getMaterialType(e){const t=this.parser;const s=t.json.materials[e];return s.extensions&&s.extensions[this.name]?u:null}extendMaterialParams(e,t){const s=this.parser;const n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const o=n.extensions[this.name];t.dispersion=o.dispersion!==void 0?o.dispersion:0;return Promise.resolve()}}class GLTFMaterialsIridescenceExtension{constructor(e){this.parser=e;this.name=de.KHR_MATERIALS_IRIDESCENCE}getMaterialType(e){const t=this.parser;const s=t.json.materials[e];return s.extensions&&s.extensions[this.name]?u:null}extendMaterialParams(e,t){const s=this.parser;const n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const o=[];const r=n.extensions[this.name];r.iridescenceFactor!==void 0&&(t.iridescence=r.iridescenceFactor);r.iridescenceTexture!==void 0&&o.push(s.assignTexture(t,"iridescenceMap",r.iridescenceTexture));r.iridescenceIor!==void 0&&(t.iridescenceIOR=r.iridescenceIor);t.iridescenceThicknessRange===void 0&&(t.iridescenceThicknessRange=[100,400]);r.iridescenceThicknessMinimum!==void 0&&(t.iridescenceThicknessRange[0]=r.iridescenceThicknessMinimum);r.iridescenceThicknessMaximum!==void 0&&(t.iridescenceThicknessRange[1]=r.iridescenceThicknessMaximum);r.iridescenceThicknessTexture!==void 0&&o.push(s.assignTexture(t,"iridescenceThicknessMap",r.iridescenceThicknessTexture));return Promise.all(o)}}class GLTFMaterialsSheenExtension{constructor(e){this.parser=e;this.name=de.KHR_MATERIALS_SHEEN}getMaterialType(e){const t=this.parser;const s=t.json.materials[e];return s.extensions&&s.extensions[this.name]?u:null}extendMaterialParams(e,t){const s=this.parser;const r=s.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const i=[];t.sheenColor=new n(0,0,0);t.sheenRoughness=0;t.sheen=1;const a=r.extensions[this.name];if(a.sheenColorFactor!==void 0){const e=a.sheenColorFactor;t.sheenColor.setRGB(e[0],e[1],e[2],o)}a.sheenRoughnessFactor!==void 0&&(t.sheenRoughness=a.sheenRoughnessFactor);a.sheenColorTexture!==void 0&&i.push(s.assignTexture(t,"sheenColorMap",a.sheenColorTexture,l));a.sheenRoughnessTexture!==void 0&&i.push(s.assignTexture(t,"sheenRoughnessMap",a.sheenRoughnessTexture));return Promise.all(i)}}class GLTFMaterialsTransmissionExtension{constructor(e){this.parser=e;this.name=de.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const t=this.parser;const s=t.json.materials[e];return s.extensions&&s.extensions[this.name]?u:null}extendMaterialParams(e,t){const s=this.parser;const n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const o=[];const r=n.extensions[this.name];r.transmissionFactor!==void 0&&(t.transmission=r.transmissionFactor);r.transmissionTexture!==void 0&&o.push(s.assignTexture(t,"transmissionMap",r.transmissionTexture));return Promise.all(o)}}class GLTFMaterialsVolumeExtension{constructor(e){this.parser=e;this.name=de.KHR_MATERIALS_VOLUME}getMaterialType(e){const t=this.parser;const s=t.json.materials[e];return s.extensions&&s.extensions[this.name]?u:null}extendMaterialParams(e,t){const s=this.parser;const r=s.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const i=[];const a=r.extensions[this.name];t.thickness=a.thicknessFactor!==void 0?a.thicknessFactor:0;a.thicknessTexture!==void 0&&i.push(s.assignTexture(t,"thicknessMap",a.thicknessTexture));t.attenuationDistance=a.attenuationDistance||Infinity;const c=a.attenuationColor||[1,1,1];t.attenuationColor=(new n).setRGB(c[0],c[1],c[2],o);return Promise.all(i)}}class GLTFMaterialsIorExtension{constructor(e){this.parser=e;this.name=de.KHR_MATERIALS_IOR}getMaterialType(e){const t=this.parser;const s=t.json.materials[e];return s.extensions&&s.extensions[this.name]?u:null}extendMaterialParams(e,t){const s=this.parser;const n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const o=n.extensions[this.name];t.ior=o.ior!==void 0?o.ior:1.5;return Promise.resolve()}}class GLTFMaterialsSpecularExtension{constructor(e){this.parser=e;this.name=de.KHR_MATERIALS_SPECULAR}getMaterialType(e){const t=this.parser;const s=t.json.materials[e];return s.extensions&&s.extensions[this.name]?u:null}extendMaterialParams(e,t){const s=this.parser;const r=s.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const i=[];const a=r.extensions[this.name];t.specularIntensity=a.specularFactor!==void 0?a.specularFactor:1;a.specularTexture!==void 0&&i.push(s.assignTexture(t,"specularIntensityMap",a.specularTexture));const c=a.specularColorFactor||[1,1,1];t.specularColor=(new n).setRGB(c[0],c[1],c[2],o);a.specularColorTexture!==void 0&&i.push(s.assignTexture(t,"specularColorMap",a.specularColorTexture,l));return Promise.all(i)}}class GLTFMaterialsBumpExtension{constructor(e){this.parser=e;this.name=de.EXT_MATERIALS_BUMP}getMaterialType(e){const t=this.parser;const s=t.json.materials[e];return s.extensions&&s.extensions[this.name]?u:null}extendMaterialParams(e,t){const s=this.parser;const n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const o=[];const r=n.extensions[this.name];t.bumpScale=r.bumpFactor!==void 0?r.bumpFactor:1;r.bumpTexture!==void 0&&o.push(s.assignTexture(t,"bumpMap",r.bumpTexture));return Promise.all(o)}}class GLTFMaterialsAnisotropyExtension{constructor(e){this.parser=e;this.name=de.KHR_MATERIALS_ANISOTROPY}getMaterialType(e){const t=this.parser;const s=t.json.materials[e];return s.extensions&&s.extensions[this.name]?u:null}extendMaterialParams(e,t){const s=this.parser;const n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const o=[];const r=n.extensions[this.name];r.anisotropyStrength!==void 0&&(t.anisotropy=r.anisotropyStrength);r.anisotropyRotation!==void 0&&(t.anisotropyRotation=r.anisotropyRotation);r.anisotropyTexture!==void 0&&o.push(s.assignTexture(t,"anisotropyMap",r.anisotropyTexture));return Promise.all(o)}}class GLTFTextureBasisUExtension{constructor(e){this.parser=e;this.name=de.KHR_TEXTURE_BASISU}loadTexture(e){const t=this.parser;const s=t.json;const n=s.textures[e];if(!n.extensions||!n.extensions[this.name])return null;const o=n.extensions[this.name];const r=t.options.ktx2Loader;if(!r){if(s.extensionsRequired&&s.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(e,o.source,r)}}class GLTFTextureWebPExtension{constructor(e){this.parser=e;this.name=de.EXT_TEXTURE_WEBP;this.isSupported=null}loadTexture(e){const t=this.name;const s=this.parser;const n=s.json;const o=n.textures[e];if(!o.extensions||!o.extensions[t])return null;const r=o.extensions[t];const i=n.images[r.source];let a=s.textureLoader;if(i.uri){const e=s.options.manager.getHandler(i.uri);e!==null&&(a=e)}return this.detectSupport().then((function(o){if(o)return s.loadTextureImage(e,r.source,a);if(n.extensionsRequired&&n.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return s.loadTexture(e)}))}detectSupport(){this.isSupported||(this.isSupported=new Promise((function(e){const t=new Image;t.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA";t.onload=t.onerror=function(){e(t.height===1)}})));return this.isSupported}}class GLTFTextureAVIFExtension{constructor(e){this.parser=e;this.name=de.EXT_TEXTURE_AVIF;this.isSupported=null}loadTexture(e){const t=this.name;const s=this.parser;const n=s.json;const o=n.textures[e];if(!o.extensions||!o.extensions[t])return null;const r=o.extensions[t];const i=n.images[r.source];let a=s.textureLoader;if(i.uri){const e=s.options.manager.getHandler(i.uri);e!==null&&(a=e)}return this.detectSupport().then((function(o){if(o)return s.loadTextureImage(e,r.source,a);if(n.extensionsRequired&&n.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");return s.loadTexture(e)}))}detectSupport(){this.isSupported||(this.isSupported=new Promise((function(e){const t=new Image;t.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=";t.onload=t.onerror=function(){e(t.height===1)}})));return this.isSupported}}class GLTFMeshoptCompression{constructor(e){this.name=de.EXT_MESHOPT_COMPRESSION;this.parser=e}loadBufferView(e){const t=this.parser.json;const s=t.bufferViews[e];if(s.extensions&&s.extensions[this.name]){const e=s.extensions[this.name];const n=this.parser.getDependency("buffer",e.buffer);const o=this.parser.options.meshoptDecoder;if(!o||!o.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return n.then((function(t){const s=e.byteOffset||0;const n=e.byteLength||0;const r=e.count;const i=e.byteStride;const a=new Uint8Array(t,s,n);return o.decodeGltfBufferAsync?o.decodeGltfBufferAsync(r,i,a,e.mode,e.filter).then((function(e){return e.buffer})):o.ready.then((function(){const t=new ArrayBuffer(r*i);o.decodeGltfBuffer(new Uint8Array(t),r,i,a,e.mode,e.filter);return t}))}))}return null}}class GLTFMeshGpuInstancing{constructor(e){this.name=de.EXT_MESH_GPU_INSTANCING;this.parser=e}createNodeMesh(e){const t=this.parser.json;const s=t.nodes[e];if(!s.extensions||!s.extensions[this.name]||s.mesh===void 0)return null;const n=t.meshes[s.mesh];for(const e of n.primitives)if(e.mode!==Ae.TRIANGLES&&e.mode!==Ae.TRIANGLE_STRIP&&e.mode!==Ae.TRIANGLE_FAN&&e.mode!==void 0)return null;const o=s.extensions[this.name];const r=o.attributes;const i=[];const a={};for(const e in r)i.push(this.parser.getDependency("accessor",r[e]).then((t=>{a[e]=t;return a[e]})));if(i.length<1)return null;i.push(this.parser.createNodeMesh(e));return Promise.all(i).then((e=>{const t=e.pop();const s=t.isGroup?t.children:[t];const n=e[0].count;const o=[];for(const e of s){const t=new d;const s=new m;const r=new p;const i=new m(1,1,1);const c=new f(e.geometry,e.material,n);for(let e=0;e<n;e++){a.TRANSLATION&&s.fromBufferAttribute(a.TRANSLATION,e);a.ROTATION&&r.fromBufferAttribute(a.ROTATION,e);a.SCALE&&i.fromBufferAttribute(a.SCALE,e);c.setMatrixAt(e,t.compose(s,r,i))}for(const t in a)if(t==="_COLOR_0"){const e=a[t];c.instanceColor=new T(e.array,e.itemSize,e.normalized)}else t!=="TRANSLATION"&&t!=="ROTATION"&&t!=="SCALE"&&e.geometry.setAttribute(t,a[t]);A.prototype.copy.call(c,e);this.parser.assignFinalMaterial(c);o.push(c)}if(t.isGroup){t.clear();t.add(...o);return t}return o[0]}))}}const me="glTF";const pe=12;const fe={JSON:1313821514,BIN:5130562};class GLTFBinaryExtension{constructor(e){this.name=de.KHR_BINARY_GLTF;this.content=null;this.body=null;const t=new DataView(e,0,pe);const s=new TextDecoder;this.header={magic:s.decode(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,true),length:t.getUint32(8,true)};if(this.header.magic!==me)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const n=this.header.length-pe;const o=new DataView(e,pe);let r=0;while(r<n){const t=o.getUint32(r,true);r+=4;const n=o.getUint32(r,true);r+=4;if(n===fe.JSON){const n=new Uint8Array(e,pe+r,t);this.content=s.decode(n)}else if(n===fe.BIN){const s=pe+r;this.body=e.slice(s,s+t)}r+=t}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class GLTFDracoMeshCompressionExtension{constructor(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=de.KHR_DRACO_MESH_COMPRESSION;this.json=e;this.dracoLoader=t;this.dracoLoader.preload()}decodePrimitive(e,t){const s=this.json;const n=this.dracoLoader;const r=e.extensions[this.name].bufferView;const i=e.extensions[this.name].attributes;const a={};const c={};const l={};for(const e in i){const t=_e[e]||e.toLowerCase();a[t]=i[e]}for(const t in e.attributes){const n=_e[t]||t.toLowerCase();if(i[t]!==void 0){const o=s.accessors[e.attributes[t]];const r=ge[o.componentType];l[n]=r.name;c[n]=o.normalized===true}}return t.getDependency("bufferView",r).then((function(e){return new Promise((function(t,s){n.decodeDracoFile(e,(function(e){for(const t in e.attributes){const s=e.attributes[t];const n=c[t];n!==void 0&&(s.normalized=n)}t(e)}),a,l,o,s)}))}))}}class GLTFTextureTransformExtension{constructor(){this.name=de.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){if((t.texCoord===void 0||t.texCoord===e.channel)&&t.offset===void 0&&t.rotation===void 0&&t.scale===void 0)return e;e=e.clone();t.texCoord!==void 0&&(e.channel=t.texCoord);t.offset!==void 0&&e.offset.fromArray(t.offset);t.rotation!==void 0&&(e.rotation=t.rotation);t.scale!==void 0&&e.repeat.fromArray(t.scale);e.needsUpdate=true;return e}}class GLTFMeshQuantizationExtension{constructor(){this.name=de.KHR_MESH_QUANTIZATION}}class GLTFCubicSplineInterpolant extends g{constructor(e,t,s,n){super(e,t,s,n)}copySampleValue_(e){const t=this.resultBuffer,s=this.sampleValues,n=this.valueSize,o=e*n*3+n;for(let e=0;e!==n;e++)t[e]=s[o+e];return t}interpolate_(e,t,s,n){const o=this.resultBuffer;const r=this.sampleValues;const i=this.valueSize;const a=i*2;const c=i*3;const l=n-t;const u=(s-t)/l;const h=u*u;const d=h*u;const m=e*c;const p=m-c;const f=-2*d+3*h;const T=d-h;const A=1-f;const g=T-h+u;for(let e=0;e!==i;e++){const t=r[p+e+i];const s=r[p+e+a]*l;const n=r[m+e+i];const c=r[m+e]*l;o[e]=A*t+g*s+f*n+T*c}return o}}const Te=new p;class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant{interpolate_(e,t,s,n){const o=super.interpolate_(e,t,s,n);Te.fromArray(o).normalize().toArray(o);return o}}const Ae={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123};const ge={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array};const xe={9728:x,9729:E,9984:R,9985:_,9986:L,9987:v};const Ee={33071:w,33648:M,10497:S};const Re={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16};const _e={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"};const Le={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"};const ve={CUBICSPLINE:void 0,LINEAR:y,STEP:I};const we={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function createDefaultMaterial(e){e.DefaultMaterial===void 0&&(e.DefaultMaterial=new b({color:16777215,emissive:0,metalness:1,roughness:1,transparent:false,depthTest:true,side:N}));return e.DefaultMaterial}function addUnknownExtensionsToUserData(e,t,s){for(const n in s.extensions)if(e[n]===void 0){t.userData.gltfExtensions=t.userData.gltfExtensions||{};t.userData.gltfExtensions[n]=s.extensions[n]}}
/**
 * @param {Object3D|Material|BufferGeometry} object
 * @param {GLTF.definition} gltfDef
 */function assignExtrasToUserData(e,t){t.extras!==void 0&&(typeof t.extras==="object"?Object.assign(e.userData,t.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+t.extras))}
/**
 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets
 *
 * @param {BufferGeometry} geometry
 * @param {Array<GLTF.Target>} targets
 * @param {GLTFParser} parser
 * @return {Promise<BufferGeometry>}
 */function addMorphTargets(e,t,s){let n=false;let o=false;let r=false;for(let e=0,s=t.length;e<s;e++){const s=t[e];s.POSITION!==void 0&&(n=true);s.NORMAL!==void 0&&(o=true);s.COLOR_0!==void 0&&(r=true);if(n&&o&&r)break}if(!n&&!o&&!r)return Promise.resolve(e);const i=[];const a=[];const c=[];for(let l=0,u=t.length;l<u;l++){const u=t[l];if(n){const t=u.POSITION!==void 0?s.getDependency("accessor",u.POSITION):e.attributes.position;i.push(t)}if(o){const t=u.NORMAL!==void 0?s.getDependency("accessor",u.NORMAL):e.attributes.normal;a.push(t)}if(r){const t=u.COLOR_0!==void 0?s.getDependency("accessor",u.COLOR_0):e.attributes.color;c.push(t)}}return Promise.all([Promise.all(i),Promise.all(a),Promise.all(c)]).then((function(t){const s=t[0];const i=t[1];const a=t[2];n&&(e.morphAttributes.position=s);o&&(e.morphAttributes.normal=i);r&&(e.morphAttributes.color=a);e.morphTargetsRelative=true;return e}))}
/**
 * @param {Mesh} mesh
 * @param {GLTF.Mesh} meshDef
 */function updateMorphTargets(e,t){e.updateMorphTargets();if(t.weights!==void 0)for(let s=0,n=t.weights.length;s<n;s++)e.morphTargetInfluences[s]=t.weights[s];if(t.extras&&Array.isArray(t.extras.targetNames)){const s=t.extras.targetNames;if(e.morphTargetInfluences.length===s.length){e.morphTargetDictionary={};for(let t=0,n=s.length;t<n;t++)e.morphTargetDictionary[s[t]]=t}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function createPrimitiveKey(e){let t;const s=e.extensions&&e.extensions[de.KHR_DRACO_MESH_COMPRESSION];t=s?"draco:"+s.bufferView+":"+s.indices+":"+createAttributesKey(s.attributes):e.indices+":"+createAttributesKey(e.attributes)+":"+e.mode;if(e.targets!==void 0)for(let s=0,n=e.targets.length;s<n;s++)t+=":"+createAttributesKey(e.targets[s]);return t}function createAttributesKey(e){let t="";const s=Object.keys(e).sort();for(let n=0,o=s.length;n<o;n++)t+=s[n]+":"+e[s[n]]+";";return t}function getNormalizedComponentScale(e){switch(e){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function getImageURIMimeType(e){return e.search(/\.jpe?g($|\?)/i)>0||e.search(/^data\:image\/jpeg/)===0?"image/jpeg":e.search(/\.webp($|\?)/i)>0||e.search(/^data\:image\/webp/)===0?"image/webp":"image/png"}const Me=new d;class GLTFParser{constructor(e={},t={}){this.json=e;this.extensions={};this.plugins={};this.options=t;this.cache=new GLTFRegistry;this.associations=new Map;this.primitiveCache={};this.nodeCache={};this.meshCache={refs:{},uses:{}};this.cameraCache={refs:{},uses:{}};this.lightCache={refs:{},uses:{}};this.sourceCache={};this.textureCache={};this.nodeNamesUsed={};let n=false;let o=-1;let r=false;let i=-1;if(typeof navigator!=="undefined"){const e=navigator.userAgent;n=/^((?!chrome|android).)*safari/i.test(e)===true;const t=e.match(/Version\/(\d+)/);o=n&&t?parseInt(t[1],10):-1;r=e.indexOf("Firefox")>-1;i=r?e.match(/Firefox\/([0-9]+)\./)[1]:-1}typeof createImageBitmap==="undefined"||n&&o<17||r&&i<98?this.textureLoader=new C(this.options.manager):this.textureLoader=new F(this.options.manager);this.textureLoader.setCrossOrigin(this.options.crossOrigin);this.textureLoader.setRequestHeader(this.options.requestHeader);this.fileLoader=new s(this.options.manager);this.fileLoader.setResponseType("arraybuffer");this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(true)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,t){const s=this;const n=this.json;const o=this.extensions;this.cache.removeAll();this.nodeCache={};this._invokeAll((function(e){return e._markDefs&&e._markDefs()}));Promise.all(this._invokeAll((function(e){return e.beforeRoot&&e.beforeRoot()}))).then((function(){return Promise.all([s.getDependencies("scene"),s.getDependencies("animation"),s.getDependencies("camera")])})).then((function(t){const r={scene:t[0][n.scene||0],scenes:t[0],animations:t[1],cameras:t[2],asset:n.asset,parser:s,userData:{}};addUnknownExtensionsToUserData(o,r,n);assignExtrasToUserData(r,n);return Promise.all(s._invokeAll((function(e){return e.afterRoot&&e.afterRoot(r)}))).then((function(){for(const e of r.scenes)e.updateMatrixWorld();e(r)}))})).catch(t)}_markDefs(){const e=this.json.nodes||[];const t=this.json.skins||[];const s=this.json.meshes||[];for(let s=0,n=t.length;s<n;s++){const n=t[s].joints;for(let t=0,s=n.length;t<s;t++)e[n[t]].isBone=true}for(let t=0,n=e.length;t<n;t++){const n=e[t];if(n.mesh!==void 0){this._addNodeRef(this.meshCache,n.mesh);n.skin!==void 0&&(s[n.mesh].isSkinnedMesh=true)}n.camera!==void 0&&this._addNodeRef(this.cameraCache,n.camera)}}_addNodeRef(e,t){if(t!==void 0){e.refs[t]===void 0&&(e.refs[t]=e.uses[t]=0);e.refs[t]++}}_getNodeRef(e,t,s){if(e.refs[t]<=1)return s;const n=s.clone();const updateMappings=(e,t)=>{const s=this.associations.get(e);s!=null&&this.associations.set(t,s);for(const[s,n]of e.children.entries())updateMappings(n,t.children[s])};updateMappings(s,n);n.name+="_instance_"+e.uses[t]++;return n}_invokeOne(e){const t=Object.values(this.plugins);t.push(this);for(let s=0;s<t.length;s++){const n=e(t[s]);if(n)return n}return null}_invokeAll(e){const t=Object.values(this.plugins);t.unshift(this);const s=[];for(let n=0;n<t.length;n++){const o=e(t[n]);o&&s.push(o)}return s}
/**
	 * Requests the specified dependency asynchronously, with caching.
	 * @param {string} type
	 * @param {number} index
	 * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
	 */getDependency(e,t){const s=e+":"+t;let n=this.cache.get(s);if(!n){switch(e){case"scene":n=this.loadScene(t);break;case"node":n=this._invokeOne((function(e){return e.loadNode&&e.loadNode(t)}));break;case"mesh":n=this._invokeOne((function(e){return e.loadMesh&&e.loadMesh(t)}));break;case"accessor":n=this.loadAccessor(t);break;case"bufferView":n=this._invokeOne((function(e){return e.loadBufferView&&e.loadBufferView(t)}));break;case"buffer":n=this.loadBuffer(t);break;case"material":n=this._invokeOne((function(e){return e.loadMaterial&&e.loadMaterial(t)}));break;case"texture":n=this._invokeOne((function(e){return e.loadTexture&&e.loadTexture(t)}));break;case"skin":n=this.loadSkin(t);break;case"animation":n=this._invokeOne((function(e){return e.loadAnimation&&e.loadAnimation(t)}));break;case"camera":n=this.loadCamera(t);break;default:n=this._invokeOne((function(s){return s!=this&&s.getDependency&&s.getDependency(e,t)}));if(!n)throw new Error("Unknown type: "+e);break}this.cache.add(s,n)}return n}
/**
	 * Requests all dependencies of the specified type asynchronously, with caching.
	 * @param {string} type
	 * @return {Promise<Array<Object>>}
	 */getDependencies(e){let t=this.cache.get(e);if(!t){const s=this;const n=this.json[e+(e==="mesh"?"es":"s")]||[];t=Promise.all(n.map((function(t,n){return s.getDependency(e,n)})));this.cache.add(e,t)}return t}
/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
	 * @param {number} bufferIndex
	 * @return {Promise<ArrayBuffer>}
	 */loadBuffer(e){const s=this.json.buffers[e];const n=this.fileLoader;if(s.type&&s.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+s.type+" buffer type is not supported.");if(s.uri===void 0&&e===0)return Promise.resolve(this.extensions[de.KHR_BINARY_GLTF].body);const o=this.options;return new Promise((function(e,r){n.load(t.resolveURL(s.uri,o.path),e,void 0,(function(){r(new Error('THREE.GLTFLoader: Failed to load buffer "'+s.uri+'".'))}))}))}
/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
	 * @param {number} bufferViewIndex
	 * @return {Promise<ArrayBuffer>}
	 */loadBufferView(e){const t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then((function(e){const s=t.byteLength||0;const n=t.byteOffset||0;return e.slice(n,n+s)}))}
/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
	 * @param {number} accessorIndex
	 * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
	 */loadAccessor(e){const t=this;const s=this.json;const n=this.json.accessors[e];if(n.bufferView===void 0&&n.sparse===void 0){const e=Re[n.type];const t=ge[n.componentType];const s=n.normalized===true;const o=new t(n.count*e);return Promise.resolve(new O(o,e,s))}const o=[];n.bufferView!==void 0?o.push(this.getDependency("bufferView",n.bufferView)):o.push(null);if(n.sparse!==void 0){o.push(this.getDependency("bufferView",n.sparse.indices.bufferView));o.push(this.getDependency("bufferView",n.sparse.values.bufferView))}return Promise.all(o).then((function(e){const o=e[0];const r=Re[n.type];const i=ge[n.componentType];const a=i.BYTES_PER_ELEMENT;const c=a*r;const l=n.byteOffset||0;const u=n.bufferView!==void 0?s.bufferViews[n.bufferView].byteStride:void 0;const h=n.normalized===true;let d,m;if(u&&u!==c){const e=Math.floor(l/u);const s="InterleavedBuffer:"+n.bufferView+":"+n.componentType+":"+e+":"+n.count;let c=t.cache.get(s);if(!c){d=new i(o,e*u,n.count*u/a);c=new P(d,u/a);t.cache.add(s,c)}m=new G(c,r,l%u/a,h)}else{d=o===null?new i(n.count*r):new i(o,l,n.count*r);m=new O(d,r,h)}if(n.sparse!==void 0){const t=Re.SCALAR;const s=ge[n.sparse.indices.componentType];const a=n.sparse.indices.byteOffset||0;const c=n.sparse.values.byteOffset||0;const l=new s(e[1],a,n.sparse.count*t);const u=new i(e[2],c,n.sparse.count*r);o!==null&&(m=new O(m.array.slice(),m.itemSize,m.normalized));for(let e=0,t=l.length;e<t;e++){const t=l[e];m.setX(t,u[e*r]);r>=2&&m.setY(t,u[e*r+1]);r>=3&&m.setZ(t,u[e*r+2]);r>=4&&m.setW(t,u[e*r+3]);if(r>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return m}))}
/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
	 * @param {number} textureIndex
	 * @return {Promise<THREE.Texture|null>}
	 */loadTexture(e){const t=this.json;const s=this.options;const n=t.textures[e];const o=n.source;const r=t.images[o];let i=this.textureLoader;if(r.uri){const e=s.manager.getHandler(r.uri);e!==null&&(i=e)}return this.loadTextureImage(e,o,i)}loadTextureImage(e,t,s){const n=this;const o=this.json;const r=o.textures[e];const i=o.images[t];const a=(i.uri||i.bufferView)+":"+r.sampler;if(this.textureCache[a])return this.textureCache[a];const c=this.loadImageSource(t,s).then((function(t){t.flipY=false;t.name=r.name||i.name||"";t.name===""&&typeof i.uri==="string"&&i.uri.startsWith("data:image/")===false&&(t.name=i.uri);const s=o.samplers||{};const a=s[r.sampler]||{};t.magFilter=xe[a.magFilter]||E;t.minFilter=xe[a.minFilter]||v;t.wrapS=Ee[a.wrapS]||S;t.wrapT=Ee[a.wrapT]||S;n.associations.set(t,{textures:e});return t})).catch((function(){return null}));this.textureCache[a]=c;return c}loadImageSource(e,s){const n=this;const o=this.json;const r=this.options;if(this.sourceCache[e]!==void 0)return this.sourceCache[e].then((e=>e.clone()));const i=o.images[e];const a=self.URL||self.webkitURL;let c=i.uri||"";let l=false;if(i.bufferView!==void 0)c=n.getDependency("bufferView",i.bufferView).then((function(e){l=true;const t=new Blob([e],{type:i.mimeType});c=a.createObjectURL(t);return c}));else if(i.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const u=Promise.resolve(c).then((function(e){return new Promise((function(n,o){let i=n;s.isImageBitmapLoader===true&&(i=function(e){const t=new H(e);t.needsUpdate=true;n(t)});s.load(t.resolveURL(e,r.path),i,void 0,o)}))})).then((function(e){l===true&&a.revokeObjectURL(c);assignExtrasToUserData(e,i);e.userData.mimeType=i.mimeType||getImageURIMimeType(i.uri);return e})).catch((function(e){console.error("THREE.GLTFLoader: Couldn't load texture",c);throw e}));this.sourceCache[e]=u;return u}
/**
	 * Asynchronously assigns a texture to the given material parameters.
	 * @param {Object} materialParams
	 * @param {string} mapName
	 * @param {Object} mapDef
	 * @return {Promise<Texture>}
	 */assignTexture(e,t,s,n){const o=this;return this.getDependency("texture",s.index).then((function(r){if(!r)return null;if(s.texCoord!==void 0&&s.texCoord>0){r=r.clone();r.channel=s.texCoord}if(o.extensions[de.KHR_TEXTURE_TRANSFORM]){const e=s.extensions!==void 0?s.extensions[de.KHR_TEXTURE_TRANSFORM]:void 0;if(e){const t=o.associations.get(r);r=o.extensions[de.KHR_TEXTURE_TRANSFORM].extendTexture(r,e);o.associations.set(r,t)}}n!==void 0&&(r.colorSpace=n);e[t]=r;return r}))}
/**
	 * Assigns final material to a Mesh, Line, or Points instance. The instance
	 * already has a material (generated from the glTF material options alone)
	 * but reuse of the same glTF material may require multiple threejs materials
	 * to accommodate different primitive types, defines, etc. New materials will
	 * be created if necessary, and reused from a cache.
	 * @param  {Object3D} mesh Mesh, Line, or Points instance.
	 */assignFinalMaterial(e){const t=e.geometry;let s=e.material;const n=t.attributes.tangent===void 0;const o=t.attributes.color!==void 0;const r=t.attributes.normal===void 0;if(e.isPoints){const e="PointsMaterial:"+s.uuid;let t=this.cache.get(e);if(!t){t=new U;D.prototype.copy.call(t,s);t.color.copy(s.color);t.map=s.map;t.sizeAttenuation=false;this.cache.add(e,t)}s=t}else if(e.isLine){const e="LineBasicMaterial:"+s.uuid;let t=this.cache.get(e);if(!t){t=new k;D.prototype.copy.call(t,s);t.color.copy(s.color);t.map=s.map;this.cache.add(e,t)}s=t}if(n||o||r){let e="ClonedMaterial:"+s.uuid+":";n&&(e+="derivative-tangents:");o&&(e+="vertex-colors:");r&&(e+="flat-shading:");let t=this.cache.get(e);if(!t){t=s.clone();o&&(t.vertexColors=true);r&&(t.flatShading=true);if(n){t.normalScale&&(t.normalScale.y*=-1);t.clearcoatNormalScale&&(t.clearcoatNormalScale.y*=-1)}this.cache.add(e,t);this.associations.set(t,this.associations.get(s))}s=t}e.material=s}getMaterialType(){return b}
/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
	 * @param {number} materialIndex
	 * @return {Promise<Material>}
	 */loadMaterial(e){const t=this;const s=this.json;const r=this.extensions;const i=s.materials[e];let a;const u={};const d=i.extensions||{};const m=[];if(d[de.KHR_MATERIALS_UNLIT]){const e=r[de.KHR_MATERIALS_UNLIT];a=e.getMaterialType();m.push(e.extendParams(u,i,t))}else{const s=i.pbrMetallicRoughness||{};u.color=new n(1,1,1);u.opacity=1;if(Array.isArray(s.baseColorFactor)){const e=s.baseColorFactor;u.color.setRGB(e[0],e[1],e[2],o);u.opacity=e[3]}s.baseColorTexture!==void 0&&m.push(t.assignTexture(u,"map",s.baseColorTexture,l));u.metalness=s.metallicFactor!==void 0?s.metallicFactor:1;u.roughness=s.roughnessFactor!==void 0?s.roughnessFactor:1;if(s.metallicRoughnessTexture!==void 0){m.push(t.assignTexture(u,"metalnessMap",s.metallicRoughnessTexture));m.push(t.assignTexture(u,"roughnessMap",s.metallicRoughnessTexture))}a=this._invokeOne((function(t){return t.getMaterialType&&t.getMaterialType(e)}));m.push(Promise.all(this._invokeAll((function(t){return t.extendMaterialParams&&t.extendMaterialParams(e,u)}))))}i.doubleSided===true&&(u.side=B);const p=i.alphaMode||we.OPAQUE;if(p===we.BLEND){u.transparent=true;u.depthWrite=false}else{u.transparent=false;p===we.MASK&&(u.alphaTest=i.alphaCutoff!==void 0?i.alphaCutoff:.5)}if(i.normalTexture!==void 0&&a!==c){m.push(t.assignTexture(u,"normalMap",i.normalTexture));u.normalScale=new h(1,1);if(i.normalTexture.scale!==void 0){const e=i.normalTexture.scale;u.normalScale.set(e,e)}}if(i.occlusionTexture!==void 0&&a!==c){m.push(t.assignTexture(u,"aoMap",i.occlusionTexture));i.occlusionTexture.strength!==void 0&&(u.aoMapIntensity=i.occlusionTexture.strength)}if(i.emissiveFactor!==void 0&&a!==c){const e=i.emissiveFactor;u.emissive=(new n).setRGB(e[0],e[1],e[2],o)}i.emissiveTexture!==void 0&&a!==c&&m.push(t.assignTexture(u,"emissiveMap",i.emissiveTexture,l));return Promise.all(m).then((function(){const s=new a(u);i.name&&(s.name=i.name);assignExtrasToUserData(s,i);t.associations.set(s,{materials:e});i.extensions&&addUnknownExtensionsToUserData(r,s,i);return s}))}createUniqueName(e){const t=K.sanitizeNodeName(e||"");if(t in this.nodeNamesUsed)return t+"_"+ ++this.nodeNamesUsed[t];this.nodeNamesUsed[t]=0;return t}
/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
	 *
	 * Creates BufferGeometries from primitives.
	 *
	 * @param {Array<GLTF.Primitive>} primitives
	 * @return {Promise<Array<BufferGeometry>>}
	 */loadGeometries(e){const t=this;const s=this.extensions;const n=this.primitiveCache;function createDracoPrimitive(e){return s[de.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e,t).then((function(s){return addPrimitiveAttributes(s,e,t)}))}const o=[];for(let s=0,r=e.length;s<r;s++){const r=e[s];const i=createPrimitiveKey(r);const a=n[i];if(a)o.push(a.promise);else{let e;e=r.extensions&&r.extensions[de.KHR_DRACO_MESH_COMPRESSION]?createDracoPrimitive(r):addPrimitiveAttributes(new j,r,t);n[i]={primitive:r,promise:e};o.push(e)}}return Promise.all(o)}
/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
	 * @param {number} meshIndex
	 * @return {Promise<Group|Mesh|SkinnedMesh>}
	 */loadMesh(e){const t=this;const s=this.json;const n=this.extensions;const o=s.meshes[e];const r=o.primitives;const i=[];for(let e=0,t=r.length;e<t;e++){const t=r[e].material===void 0?createDefaultMaterial(this.cache):this.getDependency("material",r[e].material);i.push(t)}i.push(t.loadGeometries(r));return Promise.all(i).then((function(s){const i=s.slice(0,s.length-1);const a=s[s.length-1];const c=[];for(let s=0,l=a.length;s<l;s++){const l=a[s];const u=r[s];let h;const d=i[s];if(u.mode===Ae.TRIANGLES||u.mode===Ae.TRIANGLE_STRIP||u.mode===Ae.TRIANGLE_FAN||u.mode===void 0){h=o.isSkinnedMesh===true?new V(l,d):new X(l,d);h.isSkinnedMesh===true&&h.normalizeSkinWeights();u.mode===Ae.TRIANGLE_STRIP?h.geometry=he(h.geometry,z):u.mode===Ae.TRIANGLE_FAN&&(h.geometry=he(h.geometry,q))}else if(u.mode===Ae.LINES)h=new Q(l,d);else if(u.mode===Ae.LINE_STRIP)h=new W(l,d);else if(u.mode===Ae.LINE_LOOP)h=new Y(l,d);else{if(u.mode!==Ae.POINTS)throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+u.mode);h=new Z(l,d)}Object.keys(h.geometry.morphAttributes).length>0&&updateMorphTargets(h,o);h.name=t.createUniqueName(o.name||"mesh_"+e);assignExtrasToUserData(h,o);u.extensions&&addUnknownExtensionsToUserData(n,h,u);t.assignFinalMaterial(h);c.push(h)}for(let s=0,n=c.length;s<n;s++)t.associations.set(c[s],{meshes:e,primitives:s});if(c.length===1){o.extensions&&addUnknownExtensionsToUserData(n,c[0],o);return c[0]}const l=new J;o.extensions&&addUnknownExtensionsToUserData(n,l,o);t.associations.set(l,{meshes:e});for(let e=0,t=c.length;e<t;e++)l.add(c[e]);return l}))}
/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
	 * @param {number} cameraIndex
	 * @return {Promise<THREE.Camera>}
	 */loadCamera(e){let t;const s=this.json.cameras[e];const n=s[s.type];if(n){s.type==="perspective"?t=new $(ee.radToDeg(n.yfov),n.aspectRatio||1,n.znear||1,n.zfar||2e6):s.type==="orthographic"&&(t=new te(-n.xmag,n.xmag,n.ymag,-n.ymag,n.znear,n.zfar));s.name&&(t.name=this.createUniqueName(s.name));assignExtrasToUserData(t,s);return Promise.resolve(t)}console.warn("THREE.GLTFLoader: Missing camera parameters.")}
/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
	 * @param {number} skinIndex
	 * @return {Promise<Skeleton>}
	 */loadSkin(e){const t=this.json.skins[e];const s=[];for(let e=0,n=t.joints.length;e<n;e++)s.push(this._loadNodeShallow(t.joints[e]));t.inverseBindMatrices!==void 0?s.push(this.getDependency("accessor",t.inverseBindMatrices)):s.push(null);return Promise.all(s).then((function(e){const s=e.pop();const n=e;const o=[];const r=[];for(let e=0,i=n.length;e<i;e++){const i=n[e];if(i){o.push(i);const t=new d;s!==null&&t.fromArray(s.array,e*16);r.push(t)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',t.joints[e])}return new se(o,r)}))}
/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
	 * @param {number} animationIndex
	 * @return {Promise<AnimationClip>}
	 */loadAnimation(e){const t=this.json;const s=this;const n=t.animations[e];const o=n.name?n.name:"animation_"+e;const r=[];const i=[];const a=[];const c=[];const l=[];for(let e=0,t=n.channels.length;e<t;e++){const t=n.channels[e];const s=n.samplers[t.sampler];const o=t.target;const u=o.node;const h=n.parameters!==void 0?n.parameters[s.input]:s.input;const d=n.parameters!==void 0?n.parameters[s.output]:s.output;if(o.node!==void 0){r.push(this.getDependency("node",u));i.push(this.getDependency("accessor",h));a.push(this.getDependency("accessor",d));c.push(s);l.push(o)}}return Promise.all([Promise.all(r),Promise.all(i),Promise.all(a),Promise.all(c),Promise.all(l)]).then((function(e){const t=e[0];const n=e[1];const r=e[2];const i=e[3];const a=e[4];const c=[];for(let e=0,o=t.length;e<o;e++){const o=t[e];const l=n[e];const u=r[e];const h=i[e];const d=a[e];if(o===void 0)continue;o.updateMatrix&&o.updateMatrix();const m=s._createAnimationTracks(o,l,u,h,d);if(m)for(let e=0;e<m.length;e++)c.push(m[e])}return new ne(o,void 0,c)}))}createNodeMesh(e){const t=this.json;const s=this;const n=t.nodes[e];return n.mesh===void 0?null:s.getDependency("mesh",n.mesh).then((function(e){const t=s._getNodeRef(s.meshCache,n.mesh,e);n.weights!==void 0&&t.traverse((function(e){if(e.isMesh)for(let t=0,s=n.weights.length;t<s;t++)e.morphTargetInfluences[t]=n.weights[t]}));return t}))}
/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
	 * @param {number} nodeIndex
	 * @return {Promise<Object3D>}
	 */loadNode(e){const t=this.json;const s=this;const n=t.nodes[e];const o=s._loadNodeShallow(e);const r=[];const i=n.children||[];for(let e=0,t=i.length;e<t;e++)r.push(s.getDependency("node",i[e]));const a=n.skin===void 0?Promise.resolve(null):s.getDependency("skin",n.skin);return Promise.all([o,Promise.all(r),a]).then((function(e){const t=e[0];const s=e[1];const n=e[2];n!==null&&t.traverse((function(e){e.isSkinnedMesh&&e.bind(n,Me)}));for(let e=0,n=s.length;e<n;e++)t.add(s[e]);return t}))}_loadNodeShallow(e){const t=this.json;const s=this.extensions;const n=this;if(this.nodeCache[e]!==void 0)return this.nodeCache[e];const o=t.nodes[e];const r=o.name?n.createUniqueName(o.name):"";const i=[];const a=n._invokeOne((function(t){return t.createNodeMesh&&t.createNodeMesh(e)}));a&&i.push(a);o.camera!==void 0&&i.push(n.getDependency("camera",o.camera).then((function(e){return n._getNodeRef(n.cameraCache,o.camera,e)})));n._invokeAll((function(t){return t.createNodeAttachment&&t.createNodeAttachment(e)})).forEach((function(e){i.push(e)}));this.nodeCache[e]=Promise.all(i).then((function(t){let i;i=o.isBone===true?new oe:t.length>1?new J:t.length===1?t[0]:new A;if(i!==t[0])for(let e=0,s=t.length;e<s;e++)i.add(t[e]);if(o.name){i.userData.name=o.name;i.name=r}assignExtrasToUserData(i,o);o.extensions&&addUnknownExtensionsToUserData(s,i,o);if(o.matrix!==void 0){const e=new d;e.fromArray(o.matrix);i.applyMatrix4(e)}else{o.translation!==void 0&&i.position.fromArray(o.translation);o.rotation!==void 0&&i.quaternion.fromArray(o.rotation);o.scale!==void 0&&i.scale.fromArray(o.scale)}n.associations.has(i)||n.associations.set(i,{});n.associations.get(i).nodes=e;return i}));return this.nodeCache[e]}
/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
	 * @param {number} sceneIndex
	 * @return {Promise<Group>}
	 */loadScene(e){const t=this.extensions;const s=this.json.scenes[e];const n=this;const o=new J;s.name&&(o.name=n.createUniqueName(s.name));assignExtrasToUserData(o,s);s.extensions&&addUnknownExtensionsToUserData(t,o,s);const r=s.nodes||[];const i=[];for(let e=0,t=r.length;e<t;e++)i.push(n.getDependency("node",r[e]));return Promise.all(i).then((function(e){for(let t=0,s=e.length;t<s;t++)o.add(e[t]);const reduceAssociations=e=>{const t=new Map;for(const[e,s]of n.associations)(e instanceof D||e instanceof H)&&t.set(e,s);e.traverse((e=>{const s=n.associations.get(e);s!=null&&t.set(e,s)}));return t};n.associations=reduceAssociations(o);return o}))}_createAnimationTracks(e,t,s,n,o){const r=[];const i=e.name?e.name:e.uuid;const a=[];Le[o.path]===Le.weights?e.traverse((function(e){e.morphTargetInfluences&&a.push(e.name?e.name:e.uuid)})):a.push(i);let c;switch(Le[o.path]){case Le.weights:c=ie;break;case Le.rotation:c=ae;break;case Le.position:case Le.scale:c=re;break;default:switch(s.itemSize){case 1:c=ie;break;case 2:case 3:default:c=re;break}break}const l=n.interpolation!==void 0?ve[n.interpolation]:y;const u=this._getArrayFromAccessor(s);for(let e=0,s=a.length;e<s;e++){const s=new c(a[e]+"."+Le[o.path],t.array,u,l);n.interpolation==="CUBICSPLINE"&&this._createCubicSplineTrackInterpolant(s);r.push(s)}return r}_getArrayFromAccessor(e){let t=e.array;if(e.normalized){const e=getNormalizedComponentScale(t.constructor);const s=new Float32Array(t.length);for(let n=0,o=t.length;n<o;n++)s[n]=t[n]*e;t=s}return t}_createCubicSplineTrackInterpolant(e){e.createInterpolant=function InterpolantFactoryMethodGLTFCubicSpline(e){const t=this instanceof ae?GLTFCubicSplineQuaternionInterpolant:GLTFCubicSplineInterpolant;return new t(this.times,this.values,this.getValueSize()/3,e)};e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=true}}
/**
 * @param {BufferGeometry} geometry
 * @param {GLTF.Primitive} primitiveDef
 * @param {GLTFParser} parser
 */function computeBounds(e,t,s){const n=t.attributes;const o=new ce;if(n.POSITION===void 0)return;{const e=s.json.accessors[n.POSITION];const t=e.min;const r=e.max;if(t===void 0||r===void 0){console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}o.set(new m(t[0],t[1],t[2]),new m(r[0],r[1],r[2]));if(e.normalized){const t=getNormalizedComponentScale(ge[e.componentType]);o.min.multiplyScalar(t);o.max.multiplyScalar(t)}}const r=t.targets;if(r!==void 0){const e=new m;const t=new m;for(let n=0,o=r.length;n<o;n++){const o=r[n];if(o.POSITION!==void 0){const n=s.json.accessors[o.POSITION];const r=n.min;const i=n.max;if(r!==void 0&&i!==void 0){t.setX(Math.max(Math.abs(r[0]),Math.abs(i[0])));t.setY(Math.max(Math.abs(r[1]),Math.abs(i[1])));t.setZ(Math.max(Math.abs(r[2]),Math.abs(i[2])));if(n.normalized){const e=getNormalizedComponentScale(ge[n.componentType]);t.multiplyScalar(e)}e.max(t)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}o.expandByVector(e)}e.boundingBox=o;const i=new le;o.getCenter(i.center);i.radius=o.min.distanceTo(o.max)/2;e.boundingSphere=i}
/**
 * @param {BufferGeometry} geometry
 * @param {GLTF.Primitive} primitiveDef
 * @param {GLTFParser} parser
 * @return {Promise<BufferGeometry>}
 */function addPrimitiveAttributes(e,t,s){const n=t.attributes;const r=[];function assignAttributeAccessor(t,n){return s.getDependency("accessor",t).then((function(t){e.setAttribute(n,t)}))}for(const t in n){const s=_e[t]||t.toLowerCase();s in e.attributes||r.push(assignAttributeAccessor(n[t],s))}if(t.indices!==void 0&&!e.index){const n=s.getDependency("accessor",t.indices).then((function(t){e.setIndex(t)}));r.push(n)}ue.workingColorSpace!==o&&"COLOR_0"in n&&console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${ue.workingColorSpace}" not supported.`);assignExtrasToUserData(e,t);computeBounds(e,t,s);return Promise.all(r).then((function(){return t.targets!==void 0?addMorphTargets(e,t.targets,s):e}))}export{GLTFLoader};

