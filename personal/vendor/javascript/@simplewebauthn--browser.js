function bufferToBase64URLString(e){const t=new Uint8Array(e);let r="";for(const e of t)r+=String.fromCharCode(e);const n=btoa(r);return n.replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}function base64URLStringToBuffer(e){const t=e.replace(/-/g,"+").replace(/_/g,"/");const r=(4-t.length%4)%4;const n=t.padEnd(t.length+r,"=");const o=atob(n);const i=new ArrayBuffer(o.length);const a=new Uint8Array(i);for(let e=0;e<o.length;e++)a[e]=o.charCodeAt(e);return i}function browserSupportsWebAuthn(){return window?.PublicKeyCredential!==void 0&&typeof window.PublicKeyCredential==="function"}function toPublicKeyCredentialDescriptor(e){const{id:t}=e;return{...e,id:base64URLStringToBuffer(t),transports:e.transports}}function isValidDomain(e){return e==="localhost"||/^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(e)}class WebAuthnError extends Error{constructor({message:e,code:t,cause:r,name:n}){super(e,{cause:r});this.name=n??r.name;this.code=t}}function identifyRegistrationError({error:e,options:t}){const{publicKey:r}=t;if(!r)throw Error("options was missing required publicKey property");if(e.name==="AbortError"){if(t.signal instanceof AbortSignal)return new WebAuthnError({message:"Registration ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:e})}else if(e.name==="ConstraintError"){if(r.authenticatorSelection?.requireResidentKey===true)return new WebAuthnError({message:"Discoverable credentials were required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",cause:e});if(r.authenticatorSelection?.userVerification==="required")return new WebAuthnError({message:"User verification was required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",cause:e})}else{if(e.name==="InvalidStateError")return new WebAuthnError({message:"The authenticator was previously registered",code:"ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",cause:e});if(e.name==="NotAllowedError")return new WebAuthnError({message:e.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:e});if(e.name==="NotSupportedError"){const t=r.pubKeyCredParams.filter((e=>e.type==="public-key"));return t.length===0?new WebAuthnError({message:'No entry in pubKeyCredParams was of type "public-key"',code:"ERROR_MALFORMED_PUBKEYCREDPARAMS",cause:e}):new WebAuthnError({message:"No available authenticator supported any of the specified pubKeyCredParams algorithms",code:"ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",cause:e})}if(e.name==="SecurityError"){const t=window.location.hostname;if(!isValidDomain(t))return new WebAuthnError({message:`${window.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:e});if(r.rp.id!==t)return new WebAuthnError({message:`The RP ID "${r.rp.id}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:e})}else if(e.name==="TypeError"){if(r.user.id.byteLength<1||r.user.id.byteLength>64)return new WebAuthnError({message:"User ID was not between 1 and 64 characters",code:"ERROR_INVALID_USER_ID_LENGTH",cause:e})}else if(e.name==="UnknownError")return new WebAuthnError({message:"The authenticator was unable to process the specified options, or could not create a new credential",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:e})}return e}class BaseWebAuthnAbortService{createNewAbortSignal(){if(this.controller){const e=new Error("Cancelling existing WebAuthn API call for new one");e.name="AbortError";this.controller.abort(e)}const e=new AbortController;this.controller=e;return e.signal}cancelCeremony(){if(this.controller){const e=new Error("Manually cancelling existing WebAuthn API call");e.name="AbortError";this.controller.abort(e);this.controller=void 0}}}const e=new BaseWebAuthnAbortService;const t=["cross-platform","platform"];function toAuthenticatorAttachment(e){if(e&&!(t.indexOf(e)<0))return e}async function startRegistration(t){if(!browserSupportsWebAuthn())throw new Error("WebAuthn is not supported in this browser");const r={...t,challenge:base64URLStringToBuffer(t.challenge),user:{...t.user,id:base64URLStringToBuffer(t.user.id)},excludeCredentials:t.excludeCredentials?.map(toPublicKeyCredentialDescriptor)};const n={publicKey:r};n.signal=e.createNewAbortSignal();let o;try{o=await navigator.credentials.create(n)}catch(e){throw identifyRegistrationError({error:e,options:n})}if(!o)throw new Error("Registration was not completed");const{id:i,rawId:a,response:s,type:c}=o;let u;typeof s.getTransports==="function"&&(u=s.getTransports());let l;if(typeof s.getPublicKeyAlgorithm==="function")try{l=s.getPublicKeyAlgorithm()}catch(e){warnOnBrokenImplementation("getPublicKeyAlgorithm()",e)}let h;if(typeof s.getPublicKey==="function")try{const e=s.getPublicKey();e!==null&&(h=bufferToBase64URLString(e))}catch(e){warnOnBrokenImplementation("getPublicKey()",e)}let f;if(typeof s.getAuthenticatorData==="function")try{f=bufferToBase64URLString(s.getAuthenticatorData())}catch(e){warnOnBrokenImplementation("getAuthenticatorData()",e)}return{id:i,rawId:bufferToBase64URLString(a),response:{attestationObject:bufferToBase64URLString(s.attestationObject),clientDataJSON:bufferToBase64URLString(s.clientDataJSON),transports:u,publicKeyAlgorithm:l,publicKey:h,authenticatorData:f},type:c,clientExtensionResults:o.getClientExtensionResults(),authenticatorAttachment:toAuthenticatorAttachment(o.authenticatorAttachment)}}function warnOnBrokenImplementation(e,t){console.warn(`The browser extension that intercepted this WebAuthn API call incorrectly implemented ${e}. You should report this error to them.\n`,t)}function browserSupportsWebAuthnAutofill(){if(!browserSupportsWebAuthn())return new Promise((e=>e(false)));const e=window.PublicKeyCredential;return e.isConditionalMediationAvailable===void 0?new Promise((e=>e(false))):e.isConditionalMediationAvailable()}function identifyAuthenticationError({error:e,options:t}){const{publicKey:r}=t;if(!r)throw Error("options was missing required publicKey property");if(e.name==="AbortError"){if(t.signal instanceof AbortSignal)return new WebAuthnError({message:"Authentication ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:e})}else{if(e.name==="NotAllowedError")return new WebAuthnError({message:e.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:e});if(e.name==="SecurityError"){const t=window.location.hostname;if(!isValidDomain(t))return new WebAuthnError({message:`${window.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:e});if(r.rpId!==t)return new WebAuthnError({message:`The RP ID "${r.rpId}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:e})}else if(e.name==="UnknownError")return new WebAuthnError({message:"The authenticator was unable to process the specified options, or could not create a new assertion signature",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:e})}return e}async function startAuthentication(t,r=false){if(!browserSupportsWebAuthn())throw new Error("WebAuthn is not supported in this browser");let n;t.allowCredentials?.length!==0&&(n=t.allowCredentials?.map(toPublicKeyCredentialDescriptor));const o={...t,challenge:base64URLStringToBuffer(t.challenge),allowCredentials:n};const i={};if(r){if(!await browserSupportsWebAuthnAutofill())throw Error("Browser does not support WebAuthn autofill");const e=document.querySelectorAll("input[autocomplete$='webauthn']");if(e.length<1)throw Error('No <input> with "webauthn" as the only or last value in its `autocomplete` attribute was detected');i.mediation="conditional";o.allowCredentials=[]}i.publicKey=o;i.signal=e.createNewAbortSignal();let a;try{a=await navigator.credentials.get(i)}catch(e){throw identifyAuthenticationError({error:e,options:i})}if(!a)throw new Error("Authentication was not completed");const{id:s,rawId:c,response:u,type:l}=a;let h;u.userHandle&&(h=bufferToBase64URLString(u.userHandle));return{id:s,rawId:bufferToBase64URLString(c),response:{authenticatorData:bufferToBase64URLString(u.authenticatorData),clientDataJSON:bufferToBase64URLString(u.clientDataJSON),signature:bufferToBase64URLString(u.signature),userHandle:h},type:l,clientExtensionResults:a.getClientExtensionResults(),authenticatorAttachment:toAuthenticatorAttachment(a.authenticatorAttachment)}}function platformAuthenticatorIsAvailable(){return browserSupportsWebAuthn()?PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable():new Promise((e=>e(false)))}export{e as WebAuthnAbortService,WebAuthnError,base64URLStringToBuffer,browserSupportsWebAuthn,browserSupportsWebAuthnAutofill,bufferToBase64URLString,platformAuthenticatorIsAvailable,startAuthentication,startRegistration};

